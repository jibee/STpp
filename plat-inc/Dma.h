#ifndef _DMA_H
#define _DMA_H

#include <stm32f4xx.h>
namespace Platform
{
/** DMA transfer manager
 *
 * DMA transfer is a neat way to transfer many bytes of data to
 * a peripheral without having to transfer each byte and wait for
 * the device to consume the data.
 *
 * The STM32 Platform has two DMA controller, each supporting up to
 * eight streams, each supporting up to eight channels or requests.
 *
 * The DMA controllers are able to monitor certain events (the so-called
 * channels or requests) and upon such event, initiate a memory transfer
 * without any memory copying work from the CPU.
 *
 * There are three types of transfers that can be programmed in the DMA
 * controller:
 * - Device to Memory
 * - Memory to Device
 * - Memory to Memory
 *
 * @todo allow to select the size of the data blocks
 * @todo allow control of the double-buffering
 * */
class DmaStream
{
    public:
	/** List of available DMA controllers */
	enum DMAController
	{
	    DMAController1=1,
	    DMAController2=2
	};
	/** List of streams available on the DMA controller */
	enum Stream
	{
	    S0=0,
	    S1=1,
	    S2=2,
	    S3=3,
	    S4=4,
	    S5=5,
	    S6=6,
	    S7=7
	};
	/** List of trigger channels available for a stream */
	enum Channel
	{
	    C0=0,
	    C1=1,
	    C2=2,
	    C3=3,
	    C4=4,
	    C5=5,
	    C6=6,
	    C7=7
	};
    private:
	/** DMA Controller */
	DMA_TypeDef* dma;
	/** DMA Stream within the controller */
	DMA_Stream_TypeDef* stream;
	int currentBuf;
	Stream streamId;
	DMAController dmaId;
	DmaStream& setCurrent(bool first);
	/** Obtains the IRQ number for interruptions generated by the DMA engine */
	int irqNr();
    public:
	/** Constructor
	 *
	 * @param dmaController number ID of the DMA controller. Valid values are 1 and 2.
	 * @param streamNumber stream number we intend to control. Valid values are 0 to 7
	 * @param channel channel request we intend to control. Valid values are 0 to 7
	 *
	 * */
	DmaStream(DMAController dmaController, Stream streamNumber, Channel channel);
	/**
	 * Sets the peripheral address as fixed
	 *
	 * When processing a DMA transaction, the Peripheral memory segment
	 * can be incremented to copy the next adress, or fixed to keep copying
	 * the same adress (such as a data sink...)
	 *
	 * @param fixed set to true to fix the peripheral address
	 * */
	DmaStream& peripheralFixed(bool fixed = true);
	/**
	 * Sets the central memory address as fixed
	 *
	 * When processing a DMA transaction, the Central memory segment
	 * can be incremented to copy the next adress, or fixed to keep copying
	 * the same adress (such as a data sink...)
	 *
	 * @param fixed set to true to fix the central memory address
	 * */
	DmaStream& memoryFixed(bool fixed = true);
	/** Direction of communication */
	enum direction {
	    /** Peripheral to memory */
	    P2M,
	    /** Memory to peripheral */
	    M2P,
	    /** Memory to memory */
	    M2M
	};
	/** Sets the direction of copy
	 *
	 * @param dir direction of data copy
	 */
	DmaStream& setDirection(direction dir);
	/**
	 * Allows the peripheral to control data transfers
	 *
	 * The DMA controller needs to know how many bytes of data need to be transfered.
	 * This can be set in two ways: either the software programs it with numberOfData
	 * before enabling the transfer, or we can let the peripheral provide that
	 * information.
	 *
	 * As of now only the SDIO peripheral supports this.
	 *
	 * @param p set to to true to allow the peripheral to initiate transfers
	 * set to false to manually initiate transfers
	 * */
	DmaStream& peripheralControlled(bool p=true);
	/** Indicates how many items of data need to be transfered
	 *
	 * @param c number of data items to be transfered
	 *
	 *
	 * */
	DmaStream& numberOfData(uint16_t c);
	/** Enable DMA data transfer
	 *
	 *
	 */
	DmaStream& enable();
	/**
	 * Block the execution until the transfer completes
	 *
	 * */
	DmaStream& wait();
	/**
	 * Set the adress of the peripheral target
	 *
	 * @param p address of the register to be written into or read from.
	 * Note this address can also a memory address when in M2M mode and
	 * using DMA2
	 * */
	DmaStream& setPeripheral(volatile void*);
	/**
	 * Set the adress of the memory buffer
	 *
	 * @param p address of memory buffer to be used for memory transactions
	 * */
	DmaStream& setMemory(volatile void*);
	/**
	 * Enable / disable the use of a FIFO for transfers
	 *
	 * By defaut transfers are buffered using a FIFO within the DMA controller.
	 *
	 * @param enable set to true to use the FIFO; set to false to disable the FIFO
	 * and transfer from/to the peripheral to/from the memory directly
	 *
	 * */
	DmaStream& fifo(bool enable);
};
}
#endif /* _DMA_H */
